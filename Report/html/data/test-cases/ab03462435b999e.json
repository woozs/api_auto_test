{
  "uid" : "ab03462435b999e",
  "name" : "test_get_server_snap[case_data0]",
  "fullName" : "testcase.test_09_get_server_snap.Test_Get_Server_Snap#test_get_server_snap",
  "historyId" : "8e31a8dc357cb9cbfa5db164f937e611",
  "time" : {
    "start" : 1572784289071,
    "stop" : 1572784289209,
    "duration" : 138
  },
  "status" : "failed",
  "statusMessage" : "AssertionError: 用例关联的期望文件有误\n文件路径： get_server_snap_result.json",
  "statusTrace" : "test_name = '查看云主机快照', code_json = 'get_server_snap_result.json'\nrelevance = {'admin_id': '0ec82b7380cb4d0c80058501938cdf48', 'admin_role_id': 'cc33f2c3a47247329d0ee7043c4f475f', 'description': 'api_auto_PEcOsxw5D4', 'flavor_id': 'flavor-1-1-1', ...}\n_path = 'H:\\\\api_auto_test\\\\Params\\\\Param', result = {'result': False}\n\n    def read_json(test_name, code_json, relevance, _path, result):\n        \"\"\"\n        校验内容读取\n        :param test_name: 用例名称，用作索引\n        :param code_json: 文件路径\n        :param relevance: 关联对象\n        :param _path: case路径\n        :param result: 全局结果\n        :return:\n        \"\"\"\n        # 用例中参数为json格式\n        if isinstance(code_json, dict):\n            code_json = manage(code_json, relevance)\n        # 用例中参数非json格式\n        else:\n            try:\n                with open(_path+\"/\"+code_json, \"r\", encoding=\"utf-8\") as f:\n>                   data = json.load(f)\n\nCommon\\expectedManage.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfp = <_io.TextIOWrapper name='H:\\\\api_auto_test\\\\Params\\\\Param/get_server_snap_result.json' mode='r' encoding='utf-8'>\ncls = None, object_hook = None, parse_float = None, parse_int = None\nparse_constant = None, object_pairs_hook = None, kw = {}\n\n    def load(fp, *, cls=None, object_hook=None, parse_float=None,\n            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):\n        \"\"\"Deserialize ``fp`` (a ``.read()``-supporting file-like object containing\n        a JSON document) to a Python object.\n    \n        ``object_hook`` is an optional function that will be called with the\n        result of any object literal decode (a ``dict``). The return value of\n        ``object_hook`` will be used instead of the ``dict``. This feature\n        can be used to implement custom decoders (e.g. JSON-RPC class hinting).\n    \n        ``object_pairs_hook`` is an optional function that will be called with the\n        result of any object literal decoded with an ordered list of pairs.  The\n        return value of ``object_pairs_hook`` will be used instead of the ``dict``.\n        This feature can be used to implement custom decoders that rely on the\n        order that the key and value pairs are decoded (for example,\n        collections.OrderedDict will remember the order of insertion). If\n        ``object_hook`` is also defined, the ``object_pairs_hook`` takes priority.\n    \n        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n        kwarg; otherwise ``JSONDecoder`` is used.\n    \n        \"\"\"\n        return loads(fp.read(),\n            cls=cls, object_hook=object_hook,\n            parse_float=parse_float, parse_int=parse_int,\n>           parse_constant=parse_constant, object_pairs_hook=object_pairs_hook, **kw)\n\nC:\\Users\\wuzs\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\json\\__init__.py:299: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ns = '[{\\n\\t\"json\": [\\n    {\\n    \"images\": [\\n        {\\n            \"status\": \"active\",\\n            \"name\": \"snap\",\\n   ...             \"vmware_ostype\": \"centos64Guest\",\\n            }\\n        }\\n    ]\\n}],\\n\\n\\t\"test_name\": \"查看云主机快照\"\\n}\\n]'\nencoding = None, cls = None, object_hook = None, parse_float = None\nparse_int = None, parse_constant = None, object_pairs_hook = None, kw = {}\n\n    def loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None,\n            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):\n        \"\"\"Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\n        containing a JSON document) to a Python object.\n    \n        ``object_hook`` is an optional function that will be called with the\n        result of any object literal decode (a ``dict``). The return value of\n        ``object_hook`` will be used instead of the ``dict``. This feature\n        can be used to implement custom decoders (e.g. JSON-RPC class hinting).\n    \n        ``object_pairs_hook`` is an optional function that will be called with the\n        result of any object literal decoded with an ordered list of pairs.  The\n        return value of ``object_pairs_hook`` will be used instead of the ``dict``.\n        This feature can be used to implement custom decoders that rely on the\n        order that the key and value pairs are decoded (for example,\n        collections.OrderedDict will remember the order of insertion). If\n        ``object_hook`` is also defined, the ``object_pairs_hook`` takes priority.\n    \n        ``parse_float``, if specified, will be called with the string\n        of every JSON float to be decoded. By default this is equivalent to\n        float(num_str). This can be used to use another datatype or parser\n        for JSON floats (e.g. decimal.Decimal).\n    \n        ``parse_int``, if specified, will be called with the string\n        of every JSON int to be decoded. By default this is equivalent to\n        int(num_str). This can be used to use another datatype or parser\n        for JSON integers (e.g. float).\n    \n        ``parse_constant``, if specified, will be called with one of the\n        following strings: -Infinity, Infinity, NaN.\n        This can be used to raise an exception if invalid JSON numbers\n        are encountered.\n    \n        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n        kwarg; otherwise ``JSONDecoder`` is used.\n    \n        The ``encoding`` argument is ignored and deprecated.\n    \n        \"\"\"\n        if isinstance(s, str):\n            if s.startswith('\\ufeff'):\n                raise JSONDecodeError(\"Unexpected UTF-8 BOM (decode using utf-8-sig)\",\n                                      s, 0)\n        else:\n            if not isinstance(s, (bytes, bytearray)):\n                raise TypeError('the JSON object must be str, bytes or bytearray, '\n                                'not {!r}'.format(s.__class__.__name__))\n            s = s.decode(detect_encoding(s), 'surrogatepass')\n    \n        if (cls is None and object_hook is None and\n                parse_int is None and parse_float is None and\n                parse_constant is None and object_pairs_hook is None and not kw):\n>           return _default_decoder.decode(s)\n\nC:\\Users\\wuzs\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\json\\__init__.py:354: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <json.decoder.JSONDecoder object at 0x03FD6050>\ns = '[{\\n\\t\"json\": [\\n    {\\n    \"images\": [\\n        {\\n            \"status\": \"active\",\\n            \"name\": \"snap\",\\n   ...             \"vmware_ostype\": \"centos64Guest\",\\n            }\\n        }\\n    ]\\n}],\\n\\n\\t\"test_name\": \"查看云主机快照\"\\n}\\n]'\n_w = <built-in method match of _sre.SRE_Pattern object at 0x03FD9020>\n\n    def decode(self, s, _w=WHITESPACE.match):\n        \"\"\"Return the Python representation of ``s`` (a ``str`` instance\n        containing a JSON document).\n    \n        \"\"\"\n>       obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n\nC:\\Users\\wuzs\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\json\\decoder.py:339: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <json.decoder.JSONDecoder object at 0x03FD6050>\ns = '[{\\n\\t\"json\": [\\n    {\\n    \"images\": [\\n        {\\n            \"status\": \"active\",\\n            \"name\": \"snap\",\\n   ...             \"vmware_ostype\": \"centos64Guest\",\\n            }\\n        }\\n    ]\\n}],\\n\\n\\t\"test_name\": \"查看云主机快照\"\\n}\\n]'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n>           obj, end = self.scan_once(s, idx)\nE           json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 20 column 13 (char 575)\n\nC:\\Users\\wuzs\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\json\\decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <testcase.test_09_get_server_snap.Test_Get_Server_Snap object at 0x04F9F950>\ncase_data = {'address': '/v1/images/detail?sort_key=created_at&sort_dir=desc&limit=1000&image_type=snapshot&name=${server_snap_nam...file': False, 'headers': {'Content-Type': 'application/json', 'X-Auth-Token': 'e2d62457449d4093b3e33a831228092c'}, ...}\n\n    @pytest.mark.parametrize(\"case_data\", case_dict[\"test_case\"])\n    @allure.story(\"查看虚拟机快照\")\n    \n    def test_get_server_snap(self, case_data):\n    \n        # 参数化修改test_add_project 注释\n        for k, v in enumerate(case_dict[\"test_case\"]):  # 遍历用例文件中所有用例的索引和值\n            try:\n                if case_data == v:\n                    # 修改方法的__doc__在下一次调用时生效，此为展示在报告中的用例描述\n                    Test_Get_Server_Snap.test_get_server_snap.__doc__ = case_dict[\"test_case\"][k + 1][\"info\"]\n            except IndexError:\n                pass\n    \n        if not self.result[\"result\"]:\n            # 查看类变量result的值，如果未False，则前一接口校验错误，此接口标记未失败，节约测试时间\n            pytest.xfail(\"前置接口测试失败，此接口标记为失败\")\n    \n        # send_request(_data, _host, _address,_port, _relevance, path, _success)\n        code, data = requestSend.send_request(case_data, case_dict[\"testinfo\"].get(\"host\"),\n                                              case_dict[\"testinfo\"].get(\"address\"),\n                                              str(case_dict[\"testinfo\"].get(\"port\")), self.relevance, CASE_PATH,\n                                              self.result)\n        expected_code = case_data[\"check\"][0][\"expected_code\"]\n        self.Assert.assert_code(code, expected_code)\n        # 完整校验\n        CheckResult.check(case_data[\"test_name\"], case_data[\"check\"][0], code, data, self.relevance, CASE_PATH,\n>                         self.result)\n\ntestcase\\test_09_get_server_snap.py:74: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nCommon\\CheckResult.py:39: in check\n    expected_request = expectedManage.read_json(test_name, expected_request, relevance, _path, success)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ntest_name = '查看云主机快照', code_json = 'get_server_snap_result.json'\nrelevance = {'admin_id': '0ec82b7380cb4d0c80058501938cdf48', 'admin_role_id': 'cc33f2c3a47247329d0ee7043c4f475f', 'description': 'api_auto_PEcOsxw5D4', 'flavor_id': 'flavor-1-1-1', ...}\n_path = 'H:\\\\api_auto_test\\\\Params\\\\Param', result = {'result': False}\n\n    def read_json(test_name, code_json, relevance, _path, result):\n        \"\"\"\n        校验内容读取\n        :param test_name: 用例名称，用作索引\n        :param code_json: 文件路径\n        :param relevance: 关联对象\n        :param _path: case路径\n        :param result: 全局结果\n        :return:\n        \"\"\"\n        # 用例中参数为json格式\n        if isinstance(code_json, dict):\n            code_json = manage(code_json, relevance)\n        # 用例中参数非json格式\n        else:\n            try:\n                with open(_path+\"/\"+code_json, \"r\", encoding=\"utf-8\") as f:\n                    data = json.load(f)\n                    for i in data:\n                        # 遍历，通过用例名称做索引查找到第一个期望结果后，跳出循环\n                        if i[\"test_name\"] == test_name:\n                            code_json = i[\"json\"]\n                            break\n                    # 如果code_json为空，表示未找到用例关联的期望结果\n                    if not code_json:\n                        result[\"result\"] = False\n                        raise failureException(\"未找到用例关联的期望结果\\n文件路径： %s\\n索引： %s\" % (code_json, test_name))\n                    else:\n                        code_json = manage(code_json, relevance)\n    \n                    # code_json = dict(code_json)\n            # 文件不存在\n            except FileNotFoundError:\n                result[\"result\"] = False\n                raise failureException(\"用例关联文件不存在\\n文件路径： %s\" % code_json)\n            # 文件存在，但里面存储的数据有误，json.load执行异常\n            except JSONDecodeError:\n                result[\"result\"] = False\n>               raise failureException(\"用例关联的期望文件有误\\n文件路径： %s\" % code_json)\nE               AssertionError: 用例关联的期望文件有误\nE               文件路径： get_server_snap_result.json\n\nCommon\\expectedManage.py:54: AssertionError",
  "flaky" : false,
  "newFailed" : false,
  "beforeStages" : [ {
    "name" : "_Class__pytest_setup_class",
    "time" : {
      "start" : 1572784288851,
      "stop" : 1572784289068,
      "duration" : 217
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "hasContent" : false,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false
  } ],
  "testStage" : {
    "status" : "failed",
    "statusMessage" : "AssertionError: 用例关联的期望文件有误\n文件路径： get_server_snap_result.json",
    "statusTrace" : "test_name = '查看云主机快照', code_json = 'get_server_snap_result.json'\nrelevance = {'admin_id': '0ec82b7380cb4d0c80058501938cdf48', 'admin_role_id': 'cc33f2c3a47247329d0ee7043c4f475f', 'description': 'api_auto_PEcOsxw5D4', 'flavor_id': 'flavor-1-1-1', ...}\n_path = 'H:\\\\api_auto_test\\\\Params\\\\Param', result = {'result': False}\n\n    def read_json(test_name, code_json, relevance, _path, result):\n        \"\"\"\n        校验内容读取\n        :param test_name: 用例名称，用作索引\n        :param code_json: 文件路径\n        :param relevance: 关联对象\n        :param _path: case路径\n        :param result: 全局结果\n        :return:\n        \"\"\"\n        # 用例中参数为json格式\n        if isinstance(code_json, dict):\n            code_json = manage(code_json, relevance)\n        # 用例中参数非json格式\n        else:\n            try:\n                with open(_path+\"/\"+code_json, \"r\", encoding=\"utf-8\") as f:\n>                   data = json.load(f)\n\nCommon\\expectedManage.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfp = <_io.TextIOWrapper name='H:\\\\api_auto_test\\\\Params\\\\Param/get_server_snap_result.json' mode='r' encoding='utf-8'>\ncls = None, object_hook = None, parse_float = None, parse_int = None\nparse_constant = None, object_pairs_hook = None, kw = {}\n\n    def load(fp, *, cls=None, object_hook=None, parse_float=None,\n            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):\n        \"\"\"Deserialize ``fp`` (a ``.read()``-supporting file-like object containing\n        a JSON document) to a Python object.\n    \n        ``object_hook`` is an optional function that will be called with the\n        result of any object literal decode (a ``dict``). The return value of\n        ``object_hook`` will be used instead of the ``dict``. This feature\n        can be used to implement custom decoders (e.g. JSON-RPC class hinting).\n    \n        ``object_pairs_hook`` is an optional function that will be called with the\n        result of any object literal decoded with an ordered list of pairs.  The\n        return value of ``object_pairs_hook`` will be used instead of the ``dict``.\n        This feature can be used to implement custom decoders that rely on the\n        order that the key and value pairs are decoded (for example,\n        collections.OrderedDict will remember the order of insertion). If\n        ``object_hook`` is also defined, the ``object_pairs_hook`` takes priority.\n    \n        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n        kwarg; otherwise ``JSONDecoder`` is used.\n    \n        \"\"\"\n        return loads(fp.read(),\n            cls=cls, object_hook=object_hook,\n            parse_float=parse_float, parse_int=parse_int,\n>           parse_constant=parse_constant, object_pairs_hook=object_pairs_hook, **kw)\n\nC:\\Users\\wuzs\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\json\\__init__.py:299: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ns = '[{\\n\\t\"json\": [\\n    {\\n    \"images\": [\\n        {\\n            \"status\": \"active\",\\n            \"name\": \"snap\",\\n   ...             \"vmware_ostype\": \"centos64Guest\",\\n            }\\n        }\\n    ]\\n}],\\n\\n\\t\"test_name\": \"查看云主机快照\"\\n}\\n]'\nencoding = None, cls = None, object_hook = None, parse_float = None\nparse_int = None, parse_constant = None, object_pairs_hook = None, kw = {}\n\n    def loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None,\n            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):\n        \"\"\"Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\n        containing a JSON document) to a Python object.\n    \n        ``object_hook`` is an optional function that will be called with the\n        result of any object literal decode (a ``dict``). The return value of\n        ``object_hook`` will be used instead of the ``dict``. This feature\n        can be used to implement custom decoders (e.g. JSON-RPC class hinting).\n    \n        ``object_pairs_hook`` is an optional function that will be called with the\n        result of any object literal decoded with an ordered list of pairs.  The\n        return value of ``object_pairs_hook`` will be used instead of the ``dict``.\n        This feature can be used to implement custom decoders that rely on the\n        order that the key and value pairs are decoded (for example,\n        collections.OrderedDict will remember the order of insertion). If\n        ``object_hook`` is also defined, the ``object_pairs_hook`` takes priority.\n    \n        ``parse_float``, if specified, will be called with the string\n        of every JSON float to be decoded. By default this is equivalent to\n        float(num_str). This can be used to use another datatype or parser\n        for JSON floats (e.g. decimal.Decimal).\n    \n        ``parse_int``, if specified, will be called with the string\n        of every JSON int to be decoded. By default this is equivalent to\n        int(num_str). This can be used to use another datatype or parser\n        for JSON integers (e.g. float).\n    \n        ``parse_constant``, if specified, will be called with one of the\n        following strings: -Infinity, Infinity, NaN.\n        This can be used to raise an exception if invalid JSON numbers\n        are encountered.\n    \n        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n        kwarg; otherwise ``JSONDecoder`` is used.\n    \n        The ``encoding`` argument is ignored and deprecated.\n    \n        \"\"\"\n        if isinstance(s, str):\n            if s.startswith('\\ufeff'):\n                raise JSONDecodeError(\"Unexpected UTF-8 BOM (decode using utf-8-sig)\",\n                                      s, 0)\n        else:\n            if not isinstance(s, (bytes, bytearray)):\n                raise TypeError('the JSON object must be str, bytes or bytearray, '\n                                'not {!r}'.format(s.__class__.__name__))\n            s = s.decode(detect_encoding(s), 'surrogatepass')\n    \n        if (cls is None and object_hook is None and\n                parse_int is None and parse_float is None and\n                parse_constant is None and object_pairs_hook is None and not kw):\n>           return _default_decoder.decode(s)\n\nC:\\Users\\wuzs\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\json\\__init__.py:354: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <json.decoder.JSONDecoder object at 0x03FD6050>\ns = '[{\\n\\t\"json\": [\\n    {\\n    \"images\": [\\n        {\\n            \"status\": \"active\",\\n            \"name\": \"snap\",\\n   ...             \"vmware_ostype\": \"centos64Guest\",\\n            }\\n        }\\n    ]\\n}],\\n\\n\\t\"test_name\": \"查看云主机快照\"\\n}\\n]'\n_w = <built-in method match of _sre.SRE_Pattern object at 0x03FD9020>\n\n    def decode(self, s, _w=WHITESPACE.match):\n        \"\"\"Return the Python representation of ``s`` (a ``str`` instance\n        containing a JSON document).\n    \n        \"\"\"\n>       obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n\nC:\\Users\\wuzs\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\json\\decoder.py:339: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <json.decoder.JSONDecoder object at 0x03FD6050>\ns = '[{\\n\\t\"json\": [\\n    {\\n    \"images\": [\\n        {\\n            \"status\": \"active\",\\n            \"name\": \"snap\",\\n   ...             \"vmware_ostype\": \"centos64Guest\",\\n            }\\n        }\\n    ]\\n}],\\n\\n\\t\"test_name\": \"查看云主机快照\"\\n}\\n]'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n>           obj, end = self.scan_once(s, idx)\nE           json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 20 column 13 (char 575)\n\nC:\\Users\\wuzs\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\json\\decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <testcase.test_09_get_server_snap.Test_Get_Server_Snap object at 0x04F9F950>\ncase_data = {'address': '/v1/images/detail?sort_key=created_at&sort_dir=desc&limit=1000&image_type=snapshot&name=${server_snap_nam...file': False, 'headers': {'Content-Type': 'application/json', 'X-Auth-Token': 'e2d62457449d4093b3e33a831228092c'}, ...}\n\n    @pytest.mark.parametrize(\"case_data\", case_dict[\"test_case\"])\n    @allure.story(\"查看虚拟机快照\")\n    \n    def test_get_server_snap(self, case_data):\n    \n        # 参数化修改test_add_project 注释\n        for k, v in enumerate(case_dict[\"test_case\"]):  # 遍历用例文件中所有用例的索引和值\n            try:\n                if case_data == v:\n                    # 修改方法的__doc__在下一次调用时生效，此为展示在报告中的用例描述\n                    Test_Get_Server_Snap.test_get_server_snap.__doc__ = case_dict[\"test_case\"][k + 1][\"info\"]\n            except IndexError:\n                pass\n    \n        if not self.result[\"result\"]:\n            # 查看类变量result的值，如果未False，则前一接口校验错误，此接口标记未失败，节约测试时间\n            pytest.xfail(\"前置接口测试失败，此接口标记为失败\")\n    \n        # send_request(_data, _host, _address,_port, _relevance, path, _success)\n        code, data = requestSend.send_request(case_data, case_dict[\"testinfo\"].get(\"host\"),\n                                              case_dict[\"testinfo\"].get(\"address\"),\n                                              str(case_dict[\"testinfo\"].get(\"port\")), self.relevance, CASE_PATH,\n                                              self.result)\n        expected_code = case_data[\"check\"][0][\"expected_code\"]\n        self.Assert.assert_code(code, expected_code)\n        # 完整校验\n        CheckResult.check(case_data[\"test_name\"], case_data[\"check\"][0], code, data, self.relevance, CASE_PATH,\n>                         self.result)\n\ntestcase\\test_09_get_server_snap.py:74: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nCommon\\CheckResult.py:39: in check\n    expected_request = expectedManage.read_json(test_name, expected_request, relevance, _path, success)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ntest_name = '查看云主机快照', code_json = 'get_server_snap_result.json'\nrelevance = {'admin_id': '0ec82b7380cb4d0c80058501938cdf48', 'admin_role_id': 'cc33f2c3a47247329d0ee7043c4f475f', 'description': 'api_auto_PEcOsxw5D4', 'flavor_id': 'flavor-1-1-1', ...}\n_path = 'H:\\\\api_auto_test\\\\Params\\\\Param', result = {'result': False}\n\n    def read_json(test_name, code_json, relevance, _path, result):\n        \"\"\"\n        校验内容读取\n        :param test_name: 用例名称，用作索引\n        :param code_json: 文件路径\n        :param relevance: 关联对象\n        :param _path: case路径\n        :param result: 全局结果\n        :return:\n        \"\"\"\n        # 用例中参数为json格式\n        if isinstance(code_json, dict):\n            code_json = manage(code_json, relevance)\n        # 用例中参数非json格式\n        else:\n            try:\n                with open(_path+\"/\"+code_json, \"r\", encoding=\"utf-8\") as f:\n                    data = json.load(f)\n                    for i in data:\n                        # 遍历，通过用例名称做索引查找到第一个期望结果后，跳出循环\n                        if i[\"test_name\"] == test_name:\n                            code_json = i[\"json\"]\n                            break\n                    # 如果code_json为空，表示未找到用例关联的期望结果\n                    if not code_json:\n                        result[\"result\"] = False\n                        raise failureException(\"未找到用例关联的期望结果\\n文件路径： %s\\n索引： %s\" % (code_json, test_name))\n                    else:\n                        code_json = manage(code_json, relevance)\n    \n                    # code_json = dict(code_json)\n            # 文件不存在\n            except FileNotFoundError:\n                result[\"result\"] = False\n                raise failureException(\"用例关联文件不存在\\n文件路径： %s\" % code_json)\n            # 文件存在，但里面存储的数据有误，json.load执行异常\n            except JSONDecodeError:\n                result[\"result\"] = False\n>               raise failureException(\"用例关联的期望文件有误\\n文件路径： %s\" % code_json)\nE               AssertionError: 用例关联的期望文件有误\nE               文件路径： get_server_snap_result.json\n\nCommon\\expectedManage.py:54: AssertionError",
    "steps" : [ {
      "name" : "GET请求接口",
      "time" : {
        "start" : 1572784289074,
        "stop" : 1572784289077,
        "duration" : 3
      },
      "status" : "passed",
      "steps" : [ ],
      "attachments" : [ {
        "uid" : "5d1e04d0a171e9d1",
        "name" : "查看云主机快照",
        "source" : "5d1e04d0a171e9d1.attach",
        "type" : "text/plain",
        "size" : 15
      }, {
        "uid" : "5da0712f5965709",
        "name" : "http://192.168.54.120:9292/v1/images/detail?sort_key=created_at&sort_dir=desc&limit=1000&image_type=snapshot&name=snap_8JkrX4yjSduLBPHcmTxC",
        "source" : "5da0712f5965709.attach",
        "type" : "text/plain",
        "size" : 12
      }, {
        "uid" : "291a98e3f40cd168",
        "name" : "{'Content-Type': 'application/json', 'X-Auth-Token': 'e2d62457449d4093b3e33a831228092c'}",
        "source" : "291a98e3f40cd168.attach",
        "type" : "text/plain",
        "size" : 9
      }, {
        "uid" : "fad79fbaa2bdf0ea",
        "name" : "{'createImage': {'name': 'snap_lGcIDSpPJA6UQsqgrhve'}}",
        "source" : "fad79fbaa2bdf0ea.attach",
        "type" : "text/plain",
        "size" : 12
      } ],
      "parameters" : [ ],
      "stepsCount" : 0,
      "hasContent" : true,
      "attachmentsCount" : 4,
      "shouldDisplayMessage" : false
    } ],
    "attachments" : [ {
      "uid" : "2f9d1c6a56b49cde",
      "name" : "log",
      "source" : "2f9d1c6a56b49cde.txt",
      "type" : "text/plain",
      "size" : 5580
    } ],
    "parameters" : [ ],
    "stepsCount" : 1,
    "hasContent" : true,
    "attachmentsCount" : 5,
    "shouldDisplayMessage" : true
  },
  "afterStages" : [ {
    "name" : "_Class__pytest_setup_class::0",
    "time" : {
      "start" : 1572784289270,
      "stop" : 1572784289270,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "hasContent" : false,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false
  } ],
  "labels" : [ {
    "name" : "story",
    "value" : "查看虚拟机快照"
  }, {
    "name" : "feature",
    "value" : "查看云主机快照"
  }, {
    "name" : "parentSuite",
    "value" : "testcase"
  }, {
    "name" : "suite",
    "value" : "test_09_get_server_snap"
  }, {
    "name" : "subSuite",
    "value" : "Test_Get_Server_Snap"
  }, {
    "name" : "host",
    "value" : "wuzs"
  }, {
    "name" : "thread",
    "value" : "15108-MainThread"
  }, {
    "name" : "framework",
    "value" : "pytest"
  }, {
    "name" : "language",
    "value" : "cpython3"
  }, {
    "name" : "package",
    "value" : "testcase.test_09_get_server_snap"
  }, {
    "name" : "resultFormat",
    "value" : "allure2"
  } ],
  "parameters" : [ {
    "name" : "case_data",
    "value" : "{'test_name': '查看云主机快照', 'info': '查看云主机快照', 'http_type': 'http', 'request_type': 'get', 'parameter_type': 'raw', 'address': '/v1/images/detail?sort_key=created_at&sort_dir=desc&limit=1000&image_type=snapshot&name=${server_snap_name}$', 'headers': {'Content-Type': 'application/json', 'X-Auth-Token': '${token_id}$'}, 'timeout': 20, 'parameter': {'createImage': {'name': 'snap_$RandomString(20)$'}}, 'file': False, 'check': [{'check_type': 'json', 'datebase': None, 'expected_code': 200, 'expected_request': 'get_server_snap_result.json'}], 'relevance': None}"
  } ],
  "links" : [ ],
  "hidden" : true,
  "retry" : true,
  "extra" : {
    "categories" : [ ],
    "tags" : [ ]
  },
  "source" : "ab03462435b999e.json",
  "parameterValues" : [ "{'test_name': '查看云主机快照', 'info': '查看云主机快照', 'http_type': 'http', 'request_type': 'get', 'parameter_type': 'raw', 'address': '/v1/images/detail?sort_key=created_at&sort_dir=desc&limit=1000&image_type=snapshot&name=${server_snap_name}$', 'headers': {'Content-Type': 'application/json', 'X-Auth-Token': '${token_id}$'}, 'timeout': 20, 'parameter': {'createImage': {'name': 'snap_$RandomString(20)$'}}, 'file': False, 'check': [{'check_type': 'json', 'datebase': None, 'expected_code': 200, 'expected_request': 'get_server_snap_result.json'}], 'relevance': None}" ]
}